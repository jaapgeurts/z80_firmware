; Z80 homebrew single board computer ROM Monitor firmware
; Author: Jaap Geurts
; Date: 2021-02-01
;

;rc2014=1
sea80=1

DUMP_ROWCOUNT    equ 0x08 ; 8 rows
DUMP_BYTESPERROW equ 0x10 ; 16 bytes per row

; IO peripheral port definitions
; CTC ports
CTC_A equ 0x00
CTC_B equ 0x01
CTC_C equ 0x02
CTC_D equ 0x03

; RTC ports
  ifdef sea80
RTC    equ 0x20
RTC_CD  equ RTC+0x0d
RTC_CE  equ RTC+0x0e
RTC_CF  equ RTC+0x0f
  endif
; 16 more registers up to 0x2F

; SIO ports 
SIO_BD equ 0x41
SIO_BC equ 0x43
  ifdef sea80
SIO_AD equ 0x40
SIO_AC equ 0x42
  endif

; PIO ports
PIO_AC equ 0x60

; SIO for RC2014
  ifdef rc2014
SIO_AC equ 0x80
SIO_AD equ 0x81
  endif

; PSG ports
  ifdef sea80
PSG_REG equ 0x80
PSG_DATA equ 0x81

PSG_FINEA   equ 0
PSG_COARSEA equ 1
PSG_AMPLA   equ 8

PSG_FINEB   equ 2
PSG_COARSEB equ 3
PSG_AMPLB   equ 9

PSG_FINEC   equ 4
PSG_COARSEC equ 5
PSG_AMPLC   equ 10

PSG_ENABLE  equ 7
PSG_PORTA   equ 14
PSG_PORTB   equ 15

  endif

; TFT display
  ifdef sea80
TFT_C equ 0xA0
TFT_D equ 0xA1

ILI_WAKEUP         equ 0x11
ILI_DPY_NORMAL     equ 0x13
ILI_DPY_OFF        equ 0x28 
ILI_DPY_ON         equ 0x29
ILI_SET_COLADR     equ 0x2a
ILI_SET_ROWADR     equ 0x2b
ILI_MEM_WRITE      equ 0x2c
ILI_MEM_ACCESS_CTL equ 0x36
ILI_PXL_FMT        equ 0x3a
ILI_SET_DPY_BRIGHT equ 0x51
ILI_DPY_CTRL_VAL   equ 0x53
ILI_READ_ID4       equ 0xd3

; terminal size, total chars, font sizes
; 40x20,  800, 12x16
; 60x20, 1200,  8x16
; 60x40, 2400,  8x8
; 80x40, 3200,  6x8
FONTW equ 8
FONTH equ 16
BYTESPERFONT equ (FONTW * FONTH) / 8
COLS equ 60
ROWS equ 20
TOTALCHARS equ COLS * ROWS
DPYWIDTH equ 480
DPYHEIGHT equ 320

  endif

; constants
STACK_TOP          equ 0xFFFF
STACK_SIZE         equ 0x80 ; 128 bytes
VAR_TOP            equ STACK_TOP - STACK_SIZE
SER_BUF_TOP        equ 0xFF00
SER_BUF_SIZE       equ 0x20
READLINE_BUF_SIZE  equ 0x40 ; 64 chars
RTC_REG_COUNT      equ 0x0d

; keyboard codes 
L_SHIFT equ 0x12
R_SHIFT equ 0x59

; char literals
SOH equ 0x01
EOT equ 0x04
ACK equ 0x06
BS  equ 0x08 ; backspace code
LF  equ 0x0A
CR  equ 0x0D
NAK equ 0x15
ETB equ 0x17
CAN equ 0x18

; led masks
LED1 equ 0x02
LED2 equ 0x04
LED3 equ 0x08

;ram variables; first 128 bytes for the stack
; next 128 bytes for general variables
readline_buf equ VAR_TOP - READLINE_BUF_SIZE ; 64 bytes for the readline buffer
                                    ; 64 bytes for the rest
v_shifted    equ readline_buf - 1 ; shift keystate
v_cursor equ  v_shifted - 2  ; word
keyb_buf_wr  equ v_cursor - 2     ; write index
keyb_buf_rd  equ keyb_buf_wr - 2  ; read index
v_timestruct equ keyb_buf_rd - RTC_REG_COUNT ; time structure

v_foreground equ v_timestruct - 1
v_background equ v_foreground - 1
vt_xstart    equ v_background - 2
vt_ystart    equ vt_xstart - 2
v_tmp        equ vt_ystart - 2 ; word 
v_screenbuf  equ 0xF000

; ring buffer. Lives at 0x100 below the top
keyb_buf     equ SER_BUF_TOP - SER_BUF_SIZE; // 32 bytes keyboard ring buffer


; rst jump table

  org 0x0000  ; RST 0

start:
  ld   sp, STACK_TOP    ; stack pointer at 40k (base = 32k + 8k -1)
  jp   rom_entry

  org 0x0008 ; RST 1 getKey
  jp   getKey
  org 0x0010 ; RST 2 putChar
  jp   putChar
  org 0x0018 ; RST 3 printk
  jp   printk
  org 0x0020 ; RST 4 readline
  jp   readLine
  org 0x0028 ; RST 5
  org 0x0030 ; RST 6

  org 0x0038: ; RST 7 or  Mode 1 ISR
INTISR:
  push af
  ; interrupts are already disabled

  ; reset the interrupt in the SIO
  ld   a,0b00111000
  out  (SIO_AC),a

.intisr_check_channel_a: ; ( main port)
  ld   a, 0b00000000 ; write to WR1. Next byte is RR0
  out  (SIO_AC), a
  in   a,(SIO_AC)
  bit  0, a
  jr   z,.intisr_check_channel_b  ; no char available

  ;  if char waiting in channel a
  in   a,(SIO_AD)
  call putKey
  jr   .intisr_end

.intisr_check_channel_b: ; (ps/2 keyboard)

  ld   a, 0b00000000 ; write to WR0. Next byte is RR0
  out  (SIO_BC), a
  in   a,(SIO_BC)
  bit  0, a
  jr   z,.intisr_end  ; no char available
  
  ; if char waiting in channel b
  in   a,(SIO_BD)
  call handleKeyboard
  ;call putKey
  ;out  (SIO_AD),a

  ; enable next char int
  ld   a, 0b00100000 ; write to WR0. to reenable rx interrupt
  out  (SIO_BC), a

.intisr_end:
  pop  af
  ei
  reti

  org 0x0066: ; NMI ISR
  ei
  reti
  
  ; reserve some bytes for the interrupt handler
  ; put jump table here.
  org 0x0100

rom_entry:

  ; init variables
  ld   hl,keyb_buf
  ld   (keyb_buf_wr),hl
  ld   (keyb_buf_rd),hl
  ld   a,0
  ld   (v_shifted),a
  ld   bc,0
  ld   (v_cursor),bc


  ; set all PSG ports to output
  ld   a,PSG_ENABLE
  out  (PSG_REG),a
  ld   a,0b11111111
  out  (PSG_DATA),a

; set leds to 1
  ld   b,1*2
  call setLed

; init ctc timer
  ; baudrates - Time constant @ 3.6864 MHz
  ; 9600      - 24
  ; 19200     - 12
  ; 57600     - 4
  ; 115200    - 2
  ; baudrate in a
  ld a, 24
  call initCtc

  ; set leds to 2
  ld   b,2*2
  call setLed

; init serial
  call initSerialConsole

  ; set leds to 3
  ld   b,3*2
  call setLed

  call initDisplay

; set leds to 4
  ld   b,4*2
  call setLed

  call initSerialKeyboard

  ; set leds to 5
  ld   b,5*2
  call setLed

  call RTCInit

; set leds to 6
  ld   b,6*2
  call setLed

; setup interrupt
  im 1
  ei

welcome:
  ld   hl,rom_msg
  call prints
  ld   hl,author_msg
  call prints

  call displayClearBuffer
  call displayClear

; set leds to 7
  ld   b,7*2
  call setLed

  ld   hl,rom_msg
  call printd
  ld   hl,author_msg
  call printd

  ld   b,0
  call setLed

; main menu loop
main_loop:
  ld   hl, prompt_msg     ; print the prompt
  call printk
  
  call readLine        ; read an input line; result in hl
  call println

; get the first argument (this is the command)
  call firstToken
  ld   a,c
  cp   0
  jr   z,main_loop ; nothing to do

  push hl ; save str ptr
  push bc ; save token counters

  push hl
  pop  de ; ld de,hl
  ld   hl, command_table
.search_table
  ld   b,0    upper byte of bc
  ld   c,(hl) ; strlength of command in table
  ld   a,c
  cp   0      ; if the last byte is a 0, then we reached end of table
  jr   nz,.search_compare
  inc  sp
  inc  sp
  inc  sp
  inc  sp ; restore the stack
  ld   hl,error_msg
  call printk
  jr   main_loop
.search_compare:
  call stringCompare
  cp   1    ; is str equal; compare with true
  jr   z,.exec_command ; if true do execute command
  inc  c    ; skip three bytes (function pointer + 0)
  inc  c
  inc  c
  add  hl,bc
  jr   .search_table
.exec_command:
  ; found command. load address to jump to
  push hl
  pop  ix  ; ld  ix,hl  = start of command table
  inc  c
  add  ix,bc  ; add count to it
  ld   h,(ix+1) ; load func pointer
  ld   l,(ix)
  ld   iy,main_loop ; push return address
  pop  bc ; restore token counters
  pop  de ; the str
  push iy
  jp   (hl)  ; jump to function pointer; de is the start of the arg string; hl points to function

menu_help:
  ld   hl, help_msg
  call printk
  ret 

menu_halt:
  ld   hl, halted_msg
  call printk
  halt

; TODO: improve this (a*10+b)
menu_date:
  ; print date
  ld   hl,v_timestruct
  call RTCRead

  ld   bc,7 ; 10 day
  add  hl,bc
  ld   a,(hl)
  add  '0'
  call putChar
  dec  hl
  ld   a,(hl) ; 1day
  add  '0'
  call putChar
  ld   a,'/'
  call putChar
  inc  hl
  inc  hl
  inc  hl ; 10 month
  ld   a,(hl)
  add  '0'
  call putChar
  dec  hl
  ld   a,(hl) ; 1 month
  add  '0'
  call putChar
  ld   a,'/'
  call putChar
  inc  hl
  inc  hl
  inc  hl ; 10 year
  ld   a,(hl)
  add  '0'
  call putChar
  dec  hl
  ld   a,(hl) ; 1 year
  add  '0'
  call putChar
  ld   a,' '
  call putChar

  ld   hl,v_timestruct
  ld   c,5
  add  hl,bc
  ld   a,(hl)  ; 10 hour
  add  '0'
  call putChar
  dec  hl
  ld   a,(hl)  ; 1 hour
  add  '0'
  call putChar
  ld   a,':'
  call putChar
  dec  hl
  ld   a,(hl)  ; 10 min
  add  '0'
  call putChar
  dec  hl
  ld   a,(hl)  ; 1 min
  add  '0'
  call putChar
  ld   a,':'
  call putChar
  dec  hl
  ld   a,(hl)  ; 10 sec
  add  '0'
  call putChar
  dec  hl
  ld   a,(hl)  ; 1 sec
  add  '0'
  call putChar

  call println

  ret

menu_load:
  call getAddress
  ret  z   ; result in hl, str in de

  push hl
  ld   hl, loading_msg
  call printk
  pop  hl

  ex   de,hl
  call printk
  ex   de,hl
  call println
  
  call loadProgram  ; do actual work
  cp   1
  jr   nz, .ln1
  ld   hl,error_load_msg
  call printk 
  ret
.ln1:
  cp   2
  jr   nz, .ln2
  ld   hl,error_checksum
  call printk 
  ret
.ln2:
  ld   hl, loading_done_msg
  call printk
  ret

; src address in hl
; cmdline in de
menu_dump:
  push bc
  push hl

  call getAddress
  jr   z, .dump_end

  ; do work
  ld   c,DUMP_ROWCOUNT    ; 8 rows maximum
.dump_row:
  ld   b,DUMP_BYTESPERROW    ; 16 bytes per row
  ; print address
  ld   a,'0'
  call putChar
  ld   a,'x'
  call putChar
  push hl
  ld   a,h
  call printhex
  ld   a,l
  call printhex
  pop  hl
  push hl
.dump_hex_val:
  ; print value as hex duplets
  ld   a,' '
  call putChar
  ld   a,(hl)
  call printhex
  inc  hl
  djnz .dump_hex_val
  ld   a,' '
  call putChar
  ld   b,DUMP_BYTESPERROW  
  pop  hl
.dump_ascii_val:
  ld   a,(hl)
  cp   32
  jr   nc, .printable
  ld   a,'.'
.printable
  call putChar
  inc  hl
  djnz .dump_ascii_val
  call println
  dec  c
  jr   nz,.dump_row
.dump_end:
  pop  hl
  pop  bc
  ret

menu_run:
  call getAddress
  ret  z   ; result in hl, str in de

  jp    (hl); jump to loaded code with will return

menu_cls:
  call displayClearBuffer
  call displayClear
  ld   a,0
  ld   (v_cursor),a
  ret


; parses an address string into hl
; input: HL : string
; returns address in HL
getAddress:
  push de
  pop  hl ; ld hl,de
  call nextToken
  ld   a,c
  cp   0 ; no argument given.
  jr   nz,.getadr_start
  ld   hl,argerror_msg
  call printk
  cp   a ; set zero flag
  ret

.getadr_start:
  push bc
  push de
  push hl
  pop  de
  inc  de
  ; parse it
  ld   a,(de)
  ld   b,a
  inc  de
  ld   a,(de)
  ld   c,a
  call parseHexStr
  ld   h,a
  inc  de
  ld   a,(de)
  ld   b,a
  inc  de
  ld   a,(de)
  ld   c,a
  call parseHexStr
  ld   l,a
  pop  de
  pop  bc
  or   1; reset zero flag
  ret


; ****************
; ***
; ****************

rts_off:
  ld   a,005h     ;write into WR0: select WR5
  out  (SIO_AC),A
  ld   a,0E8h     ;DTR active, TX 8bit, BREAK off, TX on, RTS inacive
  out  (SIO_AC),A
  ret
  
rts_on:
  ld   a,005h     ;write into WR0: select WR5
  out  (SIO_AC),A
  ld   a,0EAh     ;DTR active, TX 8bit, BREAK off, TX on, RTS active
  out  (SIO_AC),A
  ret

; hl contains destination address
loadProgram:
  push bc
  ld   a,NAK ; send initial nak
  call putSerialChar
.load_program_next_block:
  ld   b,0 
  ld   c,0
.load_program_loop:
  call getKey     ; get character
  jr   nz, .block_start
  inc  b
  ld   a,b
  cp   255  ; loop in circles of 255  
  jr   nz,.load_program_loop
  ld   b,0
  inc  c    
  ld   a,c
  cp   255 ; loop 133*255 = 1s
  jr   nz,.load_program_loop
  ld   a,NAK ; 7ms expired, send a nack
  call putSerialChar
  ld   c,0
  jr   .load_program_loop ; try to read again
.block_start:
  cp   EOT   ; is it end of text
  jr   nz, .block_check_header     ; return if equal
  ld   a,ACK 
  call putSerialChar
  jr   .load_program_end
.block_check_header:
  cp   SOH   ; is it start of header
  jr   nz, .error_load ; error if not SOH
  call getKeyWait  ; blocknumber
;  cpl              ; invert blocknumber
;  ld   b, a
  call getKeyWait  ; 255-blocknumber
;  cp   b ; should be the same
;  jr   nz, .error_load
  ; load 128 bytes
  ld   c,0 ; checksum
  ld   b,128
  push hl   ; save HL in case there is a retransmit so we car restart from the beginning
.load_program_read_data: ; start reading the data
  call getKeyWait
  ld   (hl),a         ; write data to memory 
  inc  hl
  ; calc the checksum
  add  c ( a + c = char + current sum)
  ld   c,a ; move result back in b (current sum = new sum)
  ; compare 
  djnz .load_program_read_data ; did we read 128 bytes yet

  call getKeyWait ; get the checksum char
  cp   c  ; does checksum match?
  jr   nz, .error_send_nak ; TODO: uncomment
  ld   a,ACK ; 
  call putSerialChar
  inc  sp
  inc  sp ; get rid of hl
  jr   .load_program_next_block ; next block
.error_send_nak:
  pop  hl  ;; restore HL in case of error
  ld   a, NAK
  call putSerialChar
  jr   .load_program_next_block ; next block
.error_load:
  ld   a,CAN
  call putSerialChar
.load_program_end
  pop  bc
  ret


;********************
; rom library routines
;********************


; parses a hex string(two values only)
; src str in bc
; result in a
parseHexStr: 
  push bc
  ;b is higher order nibble, c is lower order nibble
  ld   a,b
  call char_to_nibble
  ld   b,a  ; put result back in b
  inc  hl
  ld   a,c
  call char_to_nibble
  ld   c,a  ; put result back in c

  ;b is higher order nibble, c is lower order nibble
  ; b << 4 | c
  sla  b
  sla  b
  sla  b
  sla  b
  ld   a,b  ; but b in a
  or   c ; or with c
  pop  bc
  ret

char_to_nibble: ; char in a
; TODO: no error checking
  push af
  sub 'A'
  jr c, htb_to_next1 ; carry was borrowed
  ; it was not negative
  add 10
  inc sp
  inc sp
  ret
htb_to_next1:
  pop af
  sub '0'
  ret
  
printhex:
  push af
  srl  a
  srl  a
  srl  a
  srl  a
  call printhex_nibble
  pop  af
  call printhex_nibble
  ret

printhex_nibble: ; converts a nibble to hex char
  push bc
  push hl
  ld   hl,hexconv_table
  and  0x0F ; take bottom nibble only
  ld   b,0
  ld   c,a
  adc  hl,bc
  ld   a,(hl)
printhex_end:
  call putChar
  pop hl
  pop bc
  ret

; returns first token in hl. Tokens separated by spaces only
; destructive to string
; pre:
;   HL pointer to string
; post:
;   HL pointer to first token
;   B chars remaining in original string after the token
;   C chars in the current token 
firstToken:
  ld   b,(hl)
  ld   c,0
getToken: ; do not call directly
  call skipSpace
  ; store hl (start of string)
  push hl
  call findSpace
  pop  hl
  ld   a,c  ; amount
  ld   (hl),a
  ret

nextToken:
  push de
  ld   c,0
  ld   d,0
  ld   e,(hl)
  add  hl,de
  inc  hl
  pop  de
  call getToken
  ret

; post:
;   B returns amount of spaces skipped
skipSpace:
  ld   a,b
  cp   0  ; string is empty
  ret  z
.nextSpace
  ; move forward until we discover a letter
  ld   a,b
  cp   0  ; while we're not at the end of the string
  jr   z,.done
  inc  hl
  dec  b
  ld   a,(hl)
  cp   ' ' ; if a space
  jr   z, .nextSpace ; found space
.done:
  inc  b
  dec  hl ; set pointer to start of string
  ret

; C returns amount of letters skipped
findSpace:
  ld   a,b
  cp   0    ; while we're not at the end of the string
  ret  z ; nothing in the string
.next_letter:
  ; move forward until we discover a space
  ld   a,b
  cp   0  ; while we're not at the end of the string
  jr   z,.done
  inc  hl
  inc  c
  dec  b
  ld   a,(hl)
  cp   ' ' ; if not a space
  jr   nz, .next_letter ; found space
  dec  c
.done:
  ret
  
RTCInit:
    ; start counting
  ld   a,0b00000000 ; 30s-adj=0, irq=0, busy=0, hold=0
  out  (RTC_CD),a
  ld   a,0b00000000 ; all clear
  out  (RTC_CE),a
  ld   a,0b00000100 ; test=0, 24hr, stop=0, reset=0
  out  (RTC_CF),a
  ret

RTCRead:

  push bc
  push hl

  ld   b,RTC_REG_COUNT
  ld   c,RTC
  call RTCCheckBusy

.RTCRead_loop:
  call RTCCheckBusy
  in   a,(c) ;
  and  0x0F ; chop off high nibble
  ld   (hl),a
  inc  c
  inc  hl
  djnz .RTCRead_loop

  ld   a,0b00000000 ; clear hold
  out  (RTC_CD),a

  pop  hl
  pop  bc
  ret

RTCCheckBusy:
  ld   a,0b00000001  
  out  (RTC_CD),a  ; set hold to 1
  in   a,(RTC_CD)  ; read busy bit;
  bit  1,a
  ; don't delay. unnecesary and is extra code
  ret  z
  ld   a,0b00000000
  out  (RTC_CD),a  ; clear hold bit
  jr   RTCCheckBusy

stringCompare: ; hl = src, de = dst
  push bc
  push de
  push hl
  ld   b,(hl)
  ; compare one by one
.str_cmp_next:
  ld   a,(de)
  cp   (hl)  ; if(src[i] != dst[i]) // compare bytes
  jr   nz, .str_cmp_ne ; false -> not equal
  inc  hl
  inc  de
  djnz .str_cmp_next
  ld   a,1  ; true
  jr   .str_cmp_end
.str_cmp_ne:
  ld   a,0 ; false
.str_cmp_end:
  pop  hl
  pop  de
  pop  bc
  ret

readLine: ; result in input_buf & hl
  push bc
  push de
  ld   de, readline_buf+1
  ld   b,0
.read_line_again:
  call getKeyWait     ; get character

  cp   CR   ; if (a ==  '\r') CR
  jr   z,.read_line_end ;
  cp   LF   ; if (a ==  '\n') LF
  jr   z,.read_line_end;
  cp   BS ;  if (a == '\h') BS
  jr   nz, .if_not_bs
  ld   a,b
  cp   0
  jr   z,.read_line_again ; at the beginning -> do nothing
  ld   a,BS  ; put the cursor one back
  call putChar
  ld   a,' '  ; erase the char from the screen
  call putChar
  ld   a,BS   ; put the cursor one back
  call putChar
  dec  b   ; one less char in the string
  dec  de
  jr   .read_line_again
.if_not_bs:
  ld   (de), a    ; input_buf[b] = a
  call putChar
  inc  de  ; next char
  inc  b  ; one more char in the string
  ; TODO: check for buffer overruns
  jr   .read_line_again
.read_line_end:
  ld   a,b
  ld   (readline_buf), a ; input_buf[0] = b
  ld   hl,readline_buf
  pop  de
  pop  bc
  ret  ; return to caller

println:
  ld   a,CR
  call putChar
  ld   a,LF
  call putChar
  ret


; hl = source address
printk: ; print kernel message to serial (uses pascal strings)

  ; TODO: check if serial is enabled
  call prints; print to serial

  call printd; print to display
  ret

prints:
  push hl
  push bc
  ld   b,(hl)
.printk_loop:
  call waitSerialTX
  inc  hl
  ld   a, (hl)
  out  (SIO_AD), a
  djnz .printk_loop
  pop  bc
  pop  hl
  ret

;   hl = b * c
multiply:
  push de
  push bc
  ld   hl,0
  ld   a,b
  or   a
  jr   z,.end
  ld   d,0
  ld   e,c
.mul_loop:
  add  hl,de
  djnz .mul_loop
.end:
  pop  bc
  pop  de
  ret

; hl by c, quotient in hl, remainder in a
division:
  push bc
  xor	a
  ld	b, 16

.loop:
  add	hl, hl
  rla
  jr	c, $+5
  cp	c
  jr	c, $+4

  sub	c
  inc	l
   
  djnz	.loop
  pop   bc 
  ret


getKeyWait:
  call getKey
  jr   z, getKeyWait
  ret

; result in a, if no data available zero bit is set
getKey:
  push hl
  push de
  di                        ; disable interrupts
  ; compare if buffer is empty
  ld   hl, (keyb_buf_wr)
  ld   de, (keyb_buf_rd) ; read pointer
  ld   a,l 
  cp   e                     ; is it equal then buffer is empty
  jr   z,.getKey_end
.getKey_take:
  ld   a,(de) ; read from position
  push af
  inc  e
  ld   a,e
  and  SER_BUF_SIZE-1
  ld   e,a
  ld  (keyb_buf_rd),de ; pointer pointer back into mem
  pop  af
.getKey_end:
  ei
  pop  de
  pop  hl
  ret

putKey:
  push hl
  push de
  push bc
  ld   b,a
  ; begin
  ld   hl,(keyb_buf_wr)
  ld   de,(keyb_buf_rd)
  dec  e
  ld   a,e
  and  SER_BUF_SIZE-1
  ld   e,a
  ld   a,l
  cp   e
  jr   z, .putKey_end  ; head = tail -1 => buffer full
.putKey_put
  ld   hl,(keyb_buf_wr)
  ld   (hl),b
  inc  l
  ld   a,l
  and  SER_BUF_SIZE-1
  ld   l,a
  ld   (keyb_buf_wr),hl
.putKey_end:
  pop  bc
  pop  de
  pop  hl
  ret

putChar:
  push af
  call putSerialChar
  pop  af
  call putDisplayChar
  ret

; print char to lcd
putDisplayChar: 
  push hl
  push de
  push bc

  ld   hl,v_screenbuf
  ld   de,(v_cursor)
  add  hl,de
 
  cp   BS
  jr   nz,.checkCR
  ; handle BS - remove previous char
  ; TODO: make sure de != 0
  dec  de
  ld   (v_cursor),de
  jr   .end_nodraw

.checkCR:
  cp   CR
  jr   nz,.checkLF
  ; recalculate the cursor position
  ld   c,COLS
  push de
  ex   de,hl ; put cursor in hl
  call division ; a = remainder
  scf
  ccf ; clear carry flag
  ld   b,0
  ld   c,a
  pop  hl
  sbc  hl,bc
  ld   (v_cursor),hl
  jr   .end_nodraw

.checkLF:
  cp   LF
  jr   nz,.placeChar
  ;   line feed
  ld   hl,COLS
  add  hl,de ; TODO: scroll screen if de > 1200
  ld   (v_cursor),hl
  jr   .end_nodraw

.placeChar
  push de  ; store start location
  ld   (hl),a
  inc  de
  ld   (v_cursor),de

  pop  bc ; load original cursor back
  ; update screen
  ; TODO: scroll screen when necessary
  call displayRepaint ; bc start; de end
.end_nodraw:
  pop  bc
  pop  de
  pop  hl
  ret

putSerialChar:
  push af
  call waitSerialTX  ; make sure we can send
  pop  af
  out  (SIO_AD), a
  ret

getSerialChar:
; check if character available
  ld   a, 0b00000000 ; write to WR0. Next byte is RR0
  out  (SIO_AC), a
  in   a, (SIO_AC)
  bit  0, a
  ret  z  ; no char available
; if yes, then read and return in a
  in   a,(SIO_AD)
  ret

getSerialCharWait:
; check if character available
  ld   a, 0b00000000 ; write to WR0. Next byte is RR0
  out  (SIO_AC), a
  in   a, (SIO_AC)
  bit  0, a
  jr   z,getSerialCharWait  ; no char available
; if yes, then read and return in a
  in   a,(SIO_AD)
  ret

waitSerialTX:  ; wait for serial port to be free
  ld   a, 0b00000000 ; write to WR0. Next byte is RR0
  out  (SIO_AC), a
  in   a, (SIO_AC)
  bit  2,a
  jr   z, waitSerialTX
  ret

  ; init the serial port
initSerialConsole:
; reset channel 0
  ld	a, 0b00110000
  out (SIO_AC), a

; prepare for writing WR4 - datasheet says write to WR4 first then other registers
  ld	a, 0b00000100 ; write to WR0. Next byte is WR4
  out	(SIO_AC), a
  ld	a, 0b01000100               ; 16x prescaler, No parity, 1 stopbit
  out	(SIO_AC), a

; enable interrupt on char (WR1)
  ld	a, 0b00000001 ; 
  out	(SIO_AC), a
  ld	a, 0b00011000 ; int on all Rx chars
  out	(SIO_AC), a

; enable receive (WR3)
  ld	a, 0b00000011
  out	(SIO_AC), a
  ld	a, 0b11000001             ; recv enable; 8bits / char
  out	(SIO_AC), a

; write register 5
  ld	a, 0b00000101
  out	(SIO_AC), a
  ld	a, 0b01101000            ; send enable
  out	(SIO_AC), a

  ret

initCtc:
  push af ; store af. it contains the baud rate time constant
; clock is 3,686,400 Hz
; clock frequency of the CTC must be 2x trigger frequency in other words:
; input frequency on TRG0 is 1,843,200Hz (must be at least than half clock freq)
  ld a, 0b01010101 ; control register, external trigger, counter mode, rising edge 
  out  (CTC_A), a
  ; baudrates - Time constant @ 1.8432 MHz
  ; 9600      - 12
  ; 19200     - 6
  ; 57600     - 2
  ; 115200    - 1
  ;ld a, 1 ; 115200 @ 1.8432 MHz
  pop  af
  out  (CTC_A), a
  ret

; KEYBOARD FUNCTIONS

handleKeyboard:

  push hl
  push bc
  ; translate scan code
  ; ignore release codes
  cp   0xf0 ; break code
  jr   nz, .check7bit
.read_kbd_break:
  call getKeyboardChar  ;read the next char
  cp   L_SHIFT
  jr   z,.read_kbd_unshifted:
  cp   R_SHIFT
  jr   nz,.read_kbd_end:
.read_kbd_unshifted:
  ld   a,0
  ld   (v_shifted),a
  jr   .read_kbd_end

.check7bit:
  ; if larger than 80; just store it otherwise translate
  cp   0x80
  jr   nc, .store
  push af
  cp   L_SHIFT
  jr   z,.read_kbd_set_shifted:
  cp   R_SHIFT
  jr   nz,.read_kbd_fetch:
.read_kbd_set_shifted:
  ld   a,1
  ld   (v_shifted),a
  pop  af
  jr   .read_kbd_end
 
.read_kbd_fetch:
  ld   hl,trans_table_normal
  ld   a,(v_shifted)
  cp   1
  jr   nz,.read_kbd_fetch_2
  ld   hl,trans_table_shifted
.read_kbd_fetch_2:
  pop  af
  ld   b, 0
  ld   c, a
  add  hl, bc
  ld   a,(hl)

.store:
  call putKey  ; store the key in the ring buffer

.read_kbd_end:
  pop  bc
  pop  hl
  ret

; support routines

getKeyboardChar:
; check if character available
  ld   a, 0b00000000 ; write to WR1. Next byte is RR0
  out  (SIO_BC), a
  in   a,(SIO_BC)
  bit  0, a
  jr   z,getKeyboardChar  ; no char available
; if yes, then read and return in a
  in   a,(SIO_BD)
  ret

  ; init the serial port
initSerialKeyboard:
; reset channel B
  ld   a, 0b00110000
  out  (SIO_BC), a

; prepare for writing WR4, must write WR4 first
  ld   a, 0b00000100 ; write to WR0. Next byte is WR4
  out  (SIO_BC), a
  ld   a, 0b00000101              ; set clock rate, odd parity, 1 stopbit
  out  (SIO_BC), a

  ; write to register 5

  ld   a, 0b00000101
  out  (SIO_BC), a
  ld   a, 0b10000010;   ; DTR low and RTS low (results in clock and data high)
  out  (SIO_BC), a

  ; enable interrupt on char (WR1)
  ld   a, 0b00000001 ; 
  out  (SIO_BC), a
  ld   a, 0b00001000 ; int on first Rx char
  out  (SIO_BC), a

; enable receive (WR3)
  ld   a, 0b00000011
  out  (SIO_BC), a
  ld   a, 0b11000001             ; recv enable; 8bits/char
  out  (SIO_BC), a

  ret

initDisplay:
  push bc

  ld   a,0x01   ; reset TFT display
  out  (TFT_C),a

  ld   b,0xff
delay1:
  djnz  delay1

 ; TODO: print what has been detected
;  ld   a,ILI_READ_ID4  ; read id
;  out  (TFT_C),a
;  in   a,(TFT_D); dummy data
;  in   a,(TFT_D) ; not relevant
;  in   a,(TFT_D)
;  call printhex
;  in   a,(TFT_D)
;  call printhex

; TODO: reduce by writing a loop and sending data from an array
  ld   a,ILI_DPY_OFF  ; dpy off
  out  (TFT_C),a

  ld   a,ILI_WAKEUP   ; wake up
  out  (TFT_C),a

  ld   a,ILI_DPY_CTRL_VAL   ; CTRL display
  out  (TFT_C),a ; 
  ld   a,0b00100100
  out  (TFT_D),a

  ld   a,ILI_SET_DPY_BRIGHT   ; write brightness
  out  (TFT_C),a ; 
  ld   a,0xff
  out  (TFT_D),a
   
  ld   a,ILI_MEM_ACCESS_CTL     ; set address mode
  out  (TFT_C),a
  ld   a,0b00100000
;  ld   a,0b00000000
  out   (TFT_D),a

  ld   a,ILI_PXL_FMT
  out  (TFT_C),a ; set pixel format
  ld   a,0b00000101
  out  (TFT_D),a

  ld   a,ILI_DPY_NORMAL
  out  (TFT_D),a

  ld   b,0xff
delay2:
  djnz  delay2

  ld   a,ILI_DPY_ON  ; dpy on
  out  (TFT_C),a

  pop  bc
  ret


printd: ; push it into the buffer; then redraw the screen
  push hl
  push bc
  push de

  ld   de,(v_cursor) ; remember start pos
  ld   (v_tmp),de

  ; add cursor index  to screenbuf start
  push hl
  ld   hl,v_screenbuf
  add  hl,de
  ex   de,hl
  pop  hl

;   ; calculate end position
;   ld   b,0
;   ld   c,(hl)
;   push hl
;   ld   hl,(v_cursor)
;   add  hl,bc
;   ld   (v_tmp2),hl
;   pop  hl

  ld   b,(hl)
.printd_loop:
  inc  hl
  ld   a, (hl)

  ; check for CR and LF
  cp   CR
  jr   nz, .checkLF
  ; move cursor to home
  ; get remainder
  push hl ; store the str pointer
  push bc ; store the str index counter
  push de ; ld hl,de
  pop  hl ; hl contains the v_cursor
  ; TODO: mask off alignment instead of division
  ld   c,COLS
  call division ; a = remainder
  scf
  ccf ; clear carry flag
  ld   b,0
  ld   c,a
  ex   de,hl ; ld hl with v_cursor(de)
  sbc  hl,bc
  ex   de,hl ; ld result back into v_cursor(de)
  pop  bc  ; restore the str index counter
  pop  hl  ; restore the str pointer
  jr   .endif
.checkLF:
  cp   LF
  jr   nz,.storeChar
  push hl
  ld   hl,COLS
  add  hl,de ; TODO: scroll screen if de > 1200
  ex   de,hl
  pop  hl
  jr   .endif
.storeChar:
  ld   (de),a
  inc  de
.endif:
  djnz .printd_loop

  ; subtract screenbuf
  scf
  ccf
  ld   hl,v_screenbuf
  ex   de,hl ; 
  sbc  hl,de
  ld   (v_cursor),hl

  ld   bc,(v_tmp)
  ld   de,(v_cursor)

  call displayRepaint

  pop  de
  pop  bc
  pop  hl

  ret

; bc: start, de: end
displayRepaint:
  push hl
  push bc
  push de

  ; draw from start(bc) to end(de)
  ld   hl,v_screenbuf
  add  hl,de ; save end location
  ld   (v_tmp),hl

  ; calculate startx = (start%60 ) * fontw
  ; calculate starty = (start/60) * fonth
  push bc
  push bc
  pop  hl ; ld hl,bc
  ld   c,60
  call division ; hl / c = hl rem a
  push hl ; push quotient (y)
  ; calc x
  ld   b,a
  ld   c,FONTW
  call multiply ; result in hl
  ld   (vt_xstart),hl
  ; calc y
  pop  hl
  ld   b,l
  ld   c,FONTH
  call multiply ; result in hl
  ld   (vt_ystart),hl
  ; go through the array. if dirty draw
  pop  bc
  ld   hl,v_screenbuf
  add  hl,bc
  push hl
  pop  bc ; ld bc,hl: bc contains start location in screenbuf

.nextGlyph:

  ; set display start and end position
  push bc
  ld   hl,(vt_xstart)
  push hl ; save start
  ld   bc,FONTW-1
  add  hl,bc
  ex   de,hl ; end in de
  pop  hl ; restore start
  call displaySetX1X2  ; from hl -> de
  ld   hl,(vt_ystart)
  push hl   ; save start
  ld   bc,FONTH-1
  add  hl,bc
  ex   de,hl ; end in de
  pop  hl
  call displaySetY1Y2
  ld   a,ILI_MEM_WRITE    ; do write
  out  (TFT_C),a
  pop  bc

  ld   a,(bc) ; load letter
  
  ; get the glyph
  ld   de,BYTESPERFONT  ; font small
  ld   hl,allletters
.findGlyph
  cp   0
  jr   z,.drawGlyph
  add  hl,de
  dec  a
  jr   nz,.findGlyph
  ; hl now points to the correct glyph

.drawGlyph:

  push bc ; contains the index into the screenbuf

  ; pixels to set
  ld   b,BYTESPERFONT ; font small
.next_byte:
  ld   a,(hl)
  ld   c, 8
.shift_bit:
  ld   d,a
  ;and  0x80
  bit  7,a
  jr   z,.pix_off
  ld   a,0xff   ; foreground white
  out  (TFT_D),a
;  ld   a,0xff
  out  (TFT_D),a
  jr   .continue
.pix_off 
  ld   a,0xf8  ; background blue TODO: move to var
  out  (TFT_D),a
  ld   a,0x00
  out  (TFT_D),a
.continue: ;
  ld   a,d
  sla  a
  dec  c
  jr   nz,.shift_bit
  inc  hl
  djnz .next_byte

  pop  bc
  
  ; done with the glyph. goto next cell
  inc  bc   ; if bc < 1200 continue at .incxy
  ld   de,(v_tmp)
  ld   a,b
  cp   d
  jr   nz,.incxy
  ld   a,c
  cp   e
  jr   nz,.incxy
  ; done drawing
  jr   .printLetEnd

.incxy:

  ld  hl,(vt_xstart)
  ld  de,FONTW
  add hl,de
  ld  a,h
  cp  1
  jr  nz, .next1
  ld  a,l
  cp  0xe0  ; one beyond the last column
  jr  nz, .next1
  ; over edge; increase y and set x to zero
  ; increase y
  ld  hl,(vt_ystart)
  ld  de,FONTH
  add hl,de
  ld  (vt_ystart),hl
  ld  hl,0  ;set x-start to zero
.next1:
  ld  (vt_xstart),hl
  jp  .nextGlyph

.printLetEnd:
  pop  de
  pop  bc
  pop  hl
  ret

; hl = x1,de = x2
displaySetX1X2:
  ld   a,ILI_SET_COLADR   ; set x1,x2
  out  (TFT_C),a
  ld   a,h
  out  (TFT_D),a
  ld   a,l
  out  (TFT_D),a
  ld   a,d
  out  (TFT_D),a
  ld   a,e
  out  (TFT_D),a
  ret
  
; set start y1,y2
; hl = y1,de = y2
displaySetY1Y2:
  ld   a,ILI_SET_ROWADR   ; set y1,y2
  out  (TFT_C),a
  ld   a,h
  out  (TFT_D),a
  ld   a,l
  out  (TFT_D),a
  ld   a,d
  out  (TFT_D),a
  ld   a,e
  out  (TFT_D),a
  ret

displayClearBuffer:
  push hl
  push bc
 ; first clear backing store
  ld   hl,v_screenbuf
  ld   c,(TOTALCHARS >> 8) + 1
  ld   b,TOTALCHARS & 0xff
.nextclear:
  ld   (hl),0
  inc  hl
  djnz .nextclear
  dec  c
  jr   nz,.nextclear
  pop  bc
  pop  hl
  ret


displayClear:
  push bc
  push de
  push hl

  ld   hl,0
  ld   de,0x01e0
  call displaySetX1X2
  ld   hl,0
  ld   de,0x0140
  call displaySetY1Y2
  ld   a,ILI_MEM_WRITE    ; do write
  out  (TFT_C),a
; loop 480x320 times = 3 * 200 * 256
  ld   d,3
  ld   bc,200
.dpyClearLoop:
  ld   a,0xf8  ; background blue TODO: move to var
  out  (TFT_D),a
  ld   a,0x00
  out  (TFT_D),a
  djnz .dpyClearLoop
  dec  c
  ld   b,0  ; dnjz decreases first then compares so is actually 256
  jr   nz,.dpyClearLoop
  dec  d
  ld   c,200
  jr   nz,.dpyClearLoop
  pop  hl
  pop  de
  pop  bc
  ret

; b led value
setLed:
; TODO: change to set led
  ; set leds to 0
  ld   a,PSG_PORTB
  out  (PSG_REG),a
  ld   a,b
  out  (PSG_DATA),a
  ret

rom_msg:          db 22,"Z80 ROM Monitor v0.4",CR,LF
author_msg:       db 30,"(C) January 2021 Jaap Geurts",CR,LF
help_msg:         db 66,"Commands: help, halt, load <addr>, dump <addr>, date, run <addr>",CR,LF
halted_msg:       db 13,"System halted"
prompt_msg:       db 2, "> "
error_msg:        db 26,"Error - unknown command.",CR,LF
loading_msg:      db 42,"Send data using Xmodem. Load program at 0x"
loading_done_msg: db 16,CR,LF,"Loading done",CR,LF
error_load_msg:   db 20,"Error loading data",CR,LF
argerror_msg:     db 27,"Wrong or missing argument",CR,LF
error_checksum:   db 10,"Checksum",CR,LF
hexconv_table:    db "0123456789ABCDEF"
rom_time:         db 0,0,0,4,5,1,5,0,3,0,1,2,5

; command jump table
command_table:
cmd_help:    db 4,"help"
             dw menu_help
cmd_halt:    db 4,"halt"
             dw menu_halt
cmd_load:    db 4,"load"
             dw menu_load
cmd_dump:    db 4,"dump"
             dw menu_dump
cmd_date:    db 4,"date"
             dw menu_date
cmd_run:     db 3,"run"
             dw menu_run
cmd_cls:     db 3,"cls"
             dw menu_cls
cmd_tab_end: db 0

    

;; PS2/ scancode set 2

SQOT equ 0x27

trans_table_normal:
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 0  ; number at the start the array
  db 0x00,0x00,0x00,0x00,0x00,0x09, '`',0x00 ; 8
  db 0x00,0x00,0x00,0x00,0x00, 'q', '1',0x00 ; 10
  db 0x00,0x00, 'z', 's', 'a', 'w', '2',0x00 ; 18
  db 0x00, 'c', 'x', 'd', 'e', '4', '3',0x00 ; 20
  db 0x00, ' ', 'v', 'f', 't', 'r', '5',0x00 ; 28
  db 0x00, 'n', 'b', 'h', 'g', 'y', '6',0x00 ; 30
  db 0x00,0x00, 'm', 'j', 'u', '7', '8',0x00 ; 38
  db 0x00, ',', 'k', 'i', 'o', '0', '9',0x00 ; 40
  db 0x00, '.', '/', 'l', ';', 'p', '-',0x00 ; 48
  db 0x00,0x00, "'",0x00, '[', '=',0x00,0x00 ; 50
  db 0x98,0x00,0x0D, ']',0x00, "\",0x00,0x00 ; 58 ; added 58=98
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00 ; 60
  db 0x00, '1',0x00, '4', '7',0x00,0x00,0x00 ; 68
  db  '0', '.', '2', '5', '6', '8',0x1b,0xb7 ; 70 ; added 77=b7
  db 0x00, '+', '3', '-', '*', '9',0xbe,0x00 ; 78 ; added 7e=0xbe
trans_table_shifted:
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 0   ; number at the start the array
  db 0x00,0x00,0x00,0x00,0x00,0x09, '~',0x00 ; 8
  db 0x00,0x00,0x00,0x00,0x00, 'Q', '!',0x00 ; 10
  db 0x00,0x00, 'Z', 'S', 'A', 'W', '@',0x00 ; 18
  db 0x00, 'C', 'X', 'D', 'E', '$', '#',0x00 ; 20
  db 0x00, ' ', 'V', 'F', 'T', 'R', '%',0x00 ; 28
  db 0x00, 'N', 'B', 'H', 'G', 'Y', '^',0x00 ; 30
  db 0x00,0x00, 'M', 'J', 'U', '&', '*',0x00 ; 38
  db 0x00, '<', 'M', 'I', 'O', ')', '(',0x00 ; 40
  db 0x00, '>', '?', 'L', ':', 'P', '_',0x00 ; 48
  db 0x00,0x00, '"',0x00, '{', '+',0x00,0x00 ; 50
  db 0x98,0x00,0x0D, '}',0x00, "|",0x00,0x00 ; 58
  db 0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00 ; 60
  db 0x00, '1',0x00, '4', '7',0x00,0x00,0x00 ; 68
  db  '0', '.', '2', '5', '6', '8',0x1b,0xb7 ; 70
  db 0x00, '+', '3', '-', '*', '9',0xbe,0x00 ; 78


allletters:
allletters_08x16:
letter0:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; '\x0'
letter1:    db 0x00,0x00,0x7e,0x81,0xa5,0x81,0x81,0xa5,0x99,0x81,0x81,0x7e,0x00,0x00,0x00,0x00 ; '\x1'
letter2:    db 0x00,0x00,0x7e,0xff,0xdb,0xff,0xff,0xdb,0xe7,0xff,0xff,0x7e,0x00,0x00,0x00,0x00 ; '\x2'
letter3:    db 0x00,0x00,0x00,0x00,0x6c,0xfe,0xfe,0xfe,0xfe,0x7c,0x38,0x10,0x00,0x00,0x00,0x00 ; '\x3'
letter4:    db 0x00,0x00,0x00,0x00,0x10,0x38,0x7c,0xfe,0x7c,0x38,0x10,0x00,0x00,0x00,0x00,0x00 ; '\x4'
letter5:    db 0x00,0x00,0x00,0x18,0x3c,0x3c,0xe7,0xe7,0xe7,0x18,0x18,0x3c,0x00,0x00,0x00,0x00 ; '\x5'
letter6:    db 0x00,0x00,0x00,0x18,0x3c,0x7e,0xff,0xff,0x7e,0x18,0x18,0x3c,0x00,0x00,0x00,0x00 ; '\x6'
letter7:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x3c,0x3c,0x18,0x00,0x00,0x00,0x00,0x00,0x00 ; '\x7'
letter8:    db 0xff,0xff,0xff,0xff,0xff,0xff,0xe7,0xc3,0xc3,0xe7,0xff,0xff,0xff,0xff,0xff,0xff ; '\x8'
letter9:    db 0x00,0x00,0x00,0x00,0x00,0x3c,0x42,0x42,0x42,0x42,0x3c,0x00,0x00,0x00,0x00,0x00 ; '\x9'
letter10:    db 0x00,0x00,0x00,0x00,0x00,0x3c,0x7e,0x7e,0x7e,0x7e,0x3c,0x00,0x00,0x00,0x00,0x00 ; '\x10'
letter11:    db 0x00,0x00,0x1e,0x0e,0x1a,0x32,0x78,0xcc,0xcc,0xcc,0xcc,0x78,0x00,0x00,0x00,0x00 ; '\x11'
letter12:    db 0x00,0x00,0x3c,0x66,0x66,0x66,0x66,0x3c,0x18,0x7e,0x18,0x18,0x00,0x00,0x00,0x00 ; '\x12'
letter13:    db 0x00,0x00,0x3f,0x33,0x3f,0x30,0x30,0x30,0x30,0x70,0xf0,0xe0,0x00,0x00,0x00,0x00 ; '\x13'
letter14:    db 0x00,0x00,0x7f,0x63,0x7f,0x63,0x63,0x63,0x63,0x67,0xe7,0xe6,0xc0,0x00,0x00,0x00 ; '\x14'
letter15:    db 0x00,0x00,0x00,0x10,0x92,0x54,0x38,0xee,0x38,0x54,0x92,0x10,0x00,0x00,0x00,0x00 ; '\x15'
letter16:    db 0x00,0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xf8,0xf0,0xe0,0xc0,0x80,0x00,0x00,0x00,0x00 ; '\x16'
letter17:    db 0x00,0x02,0x06,0x0e,0x1e,0x3e,0x7e,0x3e,0x1e,0x0e,0x06,0x02,0x00,0x00,0x00,0x00 ; '\x17'
letter18:    db 0x00,0x00,0x18,0x3c,0x7e,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,0x00,0x00,0x00,0x00 ; '\x18'
letter19:    db 0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x66,0x00,0x00,0x00,0x00 ; '\x19'
letter20:    db 0x00,0x00,0x7f,0xdb,0xdb,0xdb,0x7b,0x1b,0x1b,0x1b,0x1b,0x1b,0x00,0x00,0x00,0x00 ; '\x20'
letter21:    db 0x00,0x7c,0xc6,0x60,0x38,0x6c,0xc6,0xc6,0x6c,0x38,0x0c,0xc6,0x7c,0x00,0x00,0x00 ; '\x21'
letter22:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xfe,0xfe,0xfe,0x00,0x00,0x00,0x00 ; '\x22'
letter23:    db 0x00,0x00,0x18,0x3c,0x7e,0x18,0x18,0x18,0x7e,0x3c,0x18,0x7e,0x00,0x00,0x00,0x00 ; '\x23'
letter24:    db 0x00,0x10,0x38,0x7c,0xfe,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x00,0x00,0x00,0x00 ; '\x24'
letter25:    db 0x00,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0xfe,0x7c,0x38,0x10,0x00,0x00,0x00,0x00 ; '\x25'
letter26:    db 0x00,0x00,0x00,0x00,0x08,0x0c,0xfe,0xff,0xfe,0x0c,0x08,0x00,0x00,0x00,0x00,0x00 ; '\x26'
letter27:    db 0x00,0x00,0x00,0x00,0x10,0x30,0x7f,0xff,0x7f,0x30,0x10,0x00,0x00,0x00,0x00,0x00 ; '\x27'
letter28:    db 0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xc0,0xc0,0xfe,0x00,0x00,0x00,0x00,0x00,0x00 ; '\x28'
letter29:    db 0x00,0x00,0x00,0x00,0x00,0x28,0x6c,0xfe,0x6c,0x28,0x00,0x00,0x00,0x00,0x00,0x00 ; '\x29'
letter30:    db 0x00,0x00,0x00,0x00,0x10,0x38,0x38,0x7c,0x7c,0xfe,0xfe,0x00,0x00,0x00,0x00,0x00 ; '\x30'
letter31:    db 0x00,0x00,0x00,0x00,0xfe,0xfe,0x7c,0x7c,0x38,0x38,0x10,0x00,0x00,0x00,0x00,0x00 ; '\x31'
letter32:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; ' '
letter33:    db 0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00 ; '!'
letter34:    db 0x00,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; '"'
letter35:    db 0x00,0x00,0x00,0x6c,0x6c,0xfe,0x6c,0x6c,0x6c,0xfe,0x6c,0x6c,0x00,0x00,0x00,0x00 ; '#'
letter36:    db 0x10,0x10,0x7c,0xd6,0xd2,0xd0,0x7c,0x16,0x16,0x96,0xd6,0x7c,0x10,0x10,0x00,0x00 ; '$'
letter37:    db 0x00,0x00,0x00,0x00,0xc2,0xc6,0x0c,0x18,0x30,0x60,0xc6,0x86,0x00,0x00,0x00,0x00 ; '%'
letter38:    db 0x00,0x00,0x38,0x6c,0x6c,0x38,0x76,0xdc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00 ; '&'
letter39:    db 0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; '''
letter40:    db 0x00,0x00,0x0c,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0c,0x00,0x00,0x00,0x00 ; '('
letter41:    db 0x00,0x00,0x30,0x18,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x18,0x30,0x00,0x00,0x00,0x00 ; ')'
letter42:    db 0x00,0x00,0x00,0x00,0x00,0x66,0x3c,0xff,0x3c,0x66,0x00,0x00,0x00,0x00,0x00,0x00 ; '*'
letter43:    db 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00 ; '+'
letter44:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00 ; ','
letter45:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; '-'
letter46:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00 ; '.'
letter47:    db 0x00,0x00,0x00,0x00,0x02,0x06,0x0c,0x18,0x30,0x60,0xc0,0x80,0x00,0x00,0x00,0x00 ; '/'
letter48:    db 0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xd6,0xd6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '0'
letter49:    db 0x00,0x00,0x0c,0x1c,0x3c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x00,0x00,0x00,0x00 ; '1'
letter50:    db 0x00,0x00,0x7c,0xc6,0x06,0x0c,0x18,0x30,0x60,0xc0,0xc0,0xfe,0x00,0x00,0x00,0x00 ; '2'
letter51:    db 0x00,0x00,0x7c,0xc6,0x06,0x06,0x3c,0x06,0x06,0x06,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '3'
letter52:    db 0x00,0x00,0x0e,0x1e,0x36,0x66,0xc6,0xfe,0x06,0x06,0x06,0x06,0x00,0x00,0x00,0x00 ; '4'
letter53:    db 0x00,0x00,0xfe,0xc0,0xc0,0xc0,0xfc,0x06,0x06,0x06,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '5'
letter54:    db 0x00,0x00,0x38,0x60,0xc0,0xc0,0xfc,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '6'
letter55:    db 0x00,0x00,0xfe,0x06,0x06,0x06,0x0c,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00 ; '7'
letter56:    db 0x00,0x00,0x7c,0xc6,0xc6,0xc6,0x7c,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '8'
letter57:    db 0x00,0x00,0x7c,0xc6,0xc6,0xc6,0x7e,0x06,0x06,0x06,0x0c,0x78,0x00,0x00,0x00,0x00 ; '9'
letter58:    db 0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00 ; ':'
letter59:    db 0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00 ; ';'
letter60:    db 0x00,0x00,0x00,0x06,0x0c,0x18,0x30,0x60,0x30,0x18,0x0c,0x06,0x00,0x00,0x00,0x00 ; '<'
letter61:    db 0x00,0x00,0x00,0x00,0x00,0x7e,0x00,0x00,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; '='
letter62:    db 0x00,0x00,0x00,0x60,0x30,0x18,0x0c,0x06,0x0c,0x18,0x30,0x60,0x00,0x00,0x00,0x00 ; '>'
letter63:    db 0x00,0x00,0x7c,0xc6,0xc6,0x0c,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00 ; '?'
letter64:    db 0x00,0x00,0x00,0x7c,0xc6,0xc6,0xde,0xde,0xde,0xdc,0xc0,0x7c,0x00,0x00,0x00,0x00 ; '@'
letter65:    db 0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00 ; 'A'
letter66:    db 0x00,0x00,0xfc,0xc6,0xc6,0xc6,0xfc,0xc6,0xc6,0xc6,0xc6,0xfc,0x00,0x00,0x00,0x00 ; 'B'
letter67:    db 0x00,0x00,0x7c,0xc6,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00 ; 'C'
letter68:    db 0x00,0x00,0xf8,0xcc,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xcc,0xf8,0x00,0x00,0x00,0x00 ; 'D'
letter69:    db 0x00,0x00,0xfe,0xc0,0xc0,0xc0,0xf8,0xc0,0xc0,0xc0,0xc0,0xfe,0x00,0x00,0x00,0x00 ; 'E'
letter70:    db 0x00,0x00,0xfe,0xc0,0xc0,0xc0,0xf8,0xc0,0xc0,0xc0,0xc0,0xc0,0x00,0x00,0x00,0x00 ; 'F'
letter71:    db 0x00,0x00,0x7c,0xc6,0xc0,0xc0,0xc0,0xde,0xc6,0xc6,0xc6,0x7a,0x00,0x00,0x00,0x00 ; 'G'
letter72:    db 0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00 ; 'H'
letter73:    db 0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00 ; 'I'
letter74:    db 0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x06,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00 ; 'J'
letter75:    db 0x00,0x00,0xc6,0xc6,0xcc,0xd8,0xf0,0xf0,0xd8,0xcc,0xc6,0xc6,0x00,0x00,0x00,0x00 ; 'K'
letter76:    db 0x00,0x00,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xfe,0x00,0x00,0x00,0x00 ; 'L'
letter77:    db 0x00,0x00,0xc6,0xee,0xfe,0xfe,0xd6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00 ; 'M'
letter78:    db 0x00,0x00,0xc6,0xe6,0xf6,0xfe,0xde,0xce,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00 ; 'N'
letter79:    db 0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00 ; 'O'
letter80:    db 0x00,0x00,0xfc,0xc6,0xc6,0xc6,0xc6,0xfc,0xc0,0xc0,0xc0,0xc0,0x00,0x00,0x00,0x00 ; 'P'
letter81:    db 0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x0c,0x06,0x00,0x00 ; 'Q'
letter82:    db 0x00,0x00,0xfc,0xc6,0xc6,0xc6,0xfc,0xd8,0xcc,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00 ; 'R'
letter83:    db 0x00,0x00,0x7c,0xc6,0xc0,0xc0,0x7c,0x06,0x06,0x06,0xc6,0x7c,0x00,0x00,0x00,0x00 ; 'S'
letter84:    db 0x00,0x00,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00 ; 'T'
letter85:    db 0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00 ; 'U'
letter86:    db 0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x6c,0x38,0x10,0x00,0x00,0x00,0x00 ; 'V'
letter87:    db 0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xd6,0xd6,0xd6,0xfe,0xee,0xc6,0x00,0x00,0x00,0x00 ; 'W'
letter88:    db 0x00,0x00,0xc6,0xc6,0xc6,0x6c,0x38,0x38,0x6c,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00 ; 'X'
letter89:    db 0x00,0x00,0xc3,0xc3,0xc3,0x66,0x3c,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00 ; 'Y'
letter90:    db 0x00,0x00,0xfe,0x06,0x06,0x0c,0x18,0x30,0x60,0xc0,0xc0,0xfe,0x00,0x00,0x00,0x00 ; 'Z'
letter91:    db 0x00,0x00,0x3c,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3c,0x00,0x00,0x00,0x00 ; '['
letter92:    db 0x00,0x00,0x00,0x00,0x80,0xc0,0x60,0x30,0x18,0x0c,0x06,0x02,0x00,0x00,0x00,0x00 ; '\'
letter93:    db 0x00,0x00,0x3c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x3c,0x00,0x00,0x00,0x00 ; ']'
letter94:    db 0x10,0x38,0x6c,0xc6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; '^'
letter95:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0x00 ; '_'
letter96:    db 0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; '`'
letter97:    db 0x00,0x00,0x00,0x00,0x00,0x7c,0x06,0x7e,0xc6,0xc6,0xc6,0x7e,0x00,0x00,0x00,0x00 ; 'a'
letter98:    db 0x00,0x00,0xc0,0xc0,0xc0,0xfc,0xc6,0xc6,0xc6,0xc6,0xc6,0xfc,0x00,0x00,0x00,0x00 ; 'b'
letter99:    db 0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xc0,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00 ; 'c'
letter100:    db 0x00,0x00,0x06,0x06,0x06,0x7e,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x00,0x00,0x00,0x00 ; 'd'
letter101:    db 0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xc6,0xfe,0xc0,0xc0,0x7c,0x00,0x00,0x00,0x00 ; 'e'
letter102:    db 0x00,0x00,0x3c,0x60,0x60,0x60,0xf0,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00 ; 'f'
letter103:    db 0x00,0x00,0x00,0x00,0x00,0x7e,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x06,0x06,0x7c,0x00 ; 'g'
letter104:    db 0x00,0x00,0xc0,0xc0,0xc0,0xfc,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00 ; 'h'
letter105:    db 0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00 ; 'i'
letter106:    db 0x00,0x00,0x06,0x06,0x00,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0xc6,0xc6,0x7c,0x00 ; 'j'
letter107:    db 0x00,0x00,0xc0,0xc0,0xc0,0xc6,0xcc,0xf8,0xf0,0xd8,0xcc,0xc6,0x00,0x00,0x00,0x00 ; 'k'
letter108:    db 0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00 ; 'l'
letter109:    db 0x00,0x00,0x00,0x00,0x00,0xfc,0xfe,0xd6,0xd6,0xd6,0xd6,0xd6,0x00,0x00,0x00,0x00 ; 'm'
letter110:    db 0x00,0x00,0x00,0x00,0x00,0xfc,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00 ; 'n'
letter111:    db 0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00 ; 'o'
letter112:    db 0x00,0x00,0x00,0x00,0x00,0xfc,0xc6,0xc6,0xc6,0xc6,0xc6,0xfc,0xc0,0xc0,0xc0,0x00 ; 'p'
letter113:    db 0x00,0x00,0x00,0x00,0x00,0x7e,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x06,0x06,0x06,0x00 ; 'q'
letter114:    db 0x00,0x00,0x00,0x00,0x00,0xfc,0xc6,0xc6,0xc0,0xc0,0xc0,0xc0,0x00,0x00,0x00,0x00 ; 'r'
letter115:    db 0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xc0,0x7c,0x06,0xc6,0x7c,0x00,0x00,0x00,0x00 ; 's'
letter116:    db 0x00,0x00,0x08,0x18,0x18,0x7e,0x18,0x18,0x18,0x18,0x18,0x0e,0x00,0x00,0x00,0x00 ; 't'
letter117:    db 0x00,0x00,0x00,0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x00,0x00,0x00,0x00 ; 'u'
letter118:    db 0x00,0x00,0x00,0x00,0x00,0xc6,0xc6,0xc6,0xc6,0x6c,0x38,0x10,0x00,0x00,0x00,0x00 ; 'v'
letter119:    db 0x00,0x00,0x00,0x00,0x00,0xc6,0xc6,0xd6,0xd6,0xfe,0xee,0xc6,0x00,0x00,0x00,0x00 ; 'w'
letter120:    db 0x00,0x00,0x00,0x00,0x00,0xc6,0x6c,0x38,0x38,0x38,0x6c,0xc6,0x00,0x00,0x00,0x00 ; 'x'
letter121:    db 0x00,0x00,0x00,0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x06,0x06,0x7c,0x00 ; 'y'
letter122:    db 0x00,0x00,0x00,0x00,0x00,0xfe,0x0c,0x18,0x30,0x60,0xc0,0xfe,0x00,0x00,0x00,0x00 ; 'z'
letter123:    db 0x00,0x00,0x0e,0x18,0x18,0x30,0x60,0x30,0x18,0x18,0x18,0x0e,0x00,0x00,0x00,0x00 ; '{'
letter124:    db 0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00 ; '|'
letter125:    db 0x00,0x00,0x70,0x18,0x18,0x0c,0x06,0x0c,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00 ; '}'
letter126:    db 0x00,0x00,0x76,0xdc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; '~'
letter127:    db 0x00,0x00,0x00,0x00,0x10,0x38,0x6c,0xc6,0xc6,0xfe,0x00,0x00,0x00,0x00,0x00,0x00 ; '\x127'
letter128:    db 0x00,0x00,0x3c,0x66,0xc2,0xc0,0xc0,0xc0,0xc2,0x66,0x3c,0x0c,0x06,0x7c,0x00,0x00 ; '\x128'
letter129:    db 0x00,0x00,0xc6,0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x00,0x00,0x00,0x00 ; '\x129'
letter130:    db 0x00,0x0c,0x18,0x30,0x00,0x7c,0xc6,0xc6,0xfe,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '\x130'
letter131:    db 0x00,0x10,0x38,0x6c,0x00,0x7c,0x06,0x7e,0xc6,0xc6,0xc6,0x7e,0x00,0x00,0x00,0x00 ; '\x131'
letter132:    db 0x00,0x00,0xc6,0x00,0x00,0x7c,0x06,0x7e,0xc6,0xc6,0xc6,0x7e,0x00,0x00,0x00,0x00 ; '\x132'
letter133:    db 0x00,0x60,0x30,0x18,0x00,0x7c,0x06,0x7e,0xc6,0xc6,0xc6,0x7e,0x00,0x00,0x00,0x00 ; '\x133'
letter134:    db 0x00,0x38,0x6c,0x38,0x00,0x7c,0x06,0x7e,0xc6,0xc6,0xc6,0x7e,0x00,0x00,0x00,0x00 ; '\x134'
letter135:    db 0x00,0x00,0x00,0x00,0x3c,0x66,0x60,0x60,0x66,0x3c,0x0c,0x06,0x3c,0x00,0x00,0x00 ; '\x135'
letter136:    db 0x00,0x10,0x38,0x6c,0x00,0x7c,0xc6,0xc6,0xfe,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '\x136'
letter137:    db 0x00,0x00,0xc6,0x00,0x00,0x7c,0xc6,0xc6,0xfe,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '\x137'
letter138:    db 0x00,0x60,0x30,0x18,0x00,0x7c,0xc6,0xc6,0xfe,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '\x138'
letter139:    db 0x00,0x00,0x66,0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00 ; '\x139'
letter140:    db 0x00,0x18,0x3c,0x66,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00 ; '\x140'
letter141:    db 0x00,0x60,0x30,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00 ; '\x141'
letter142:    db 0x00,0xc6,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00 ; '\x142'
letter143:    db 0x38,0x6c,0x38,0x00,0x7c,0xc6,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00 ; '\x143'
letter144:    db 0x18,0x30,0x60,0x00,0xfe,0x66,0x60,0x7c,0x60,0x60,0x66,0xfe,0x00,0x00,0x00,0x00 ; '\x144'
letter145:    db 0x00,0x00,0x00,0x00,0x6c,0xfe,0xb2,0x32,0x7e,0xd8,0xd8,0x6e,0x00,0x00,0x00,0x00 ; '\x145'
letter146:    db 0x00,0x00,0x3f,0x6c,0xcc,0xcc,0xff,0xcc,0xcc,0xcc,0xcc,0xcf,0x00,0x00,0x00,0x00 ; '\x146'
letter147:    db 0x00,0x10,0x38,0x6c,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '\x147'
letter148:    db 0x00,0x00,0xc6,0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '\x148'
letter149:    db 0x00,0x60,0x30,0x18,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '\x149'
letter150:    db 0x00,0x30,0x78,0xcc,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x00,0x00,0x00,0x00 ; '\x150'
letter151:    db 0x00,0x60,0x30,0x18,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x00,0x00,0x00,0x00 ; '\x151'
letter152:    db 0x00,0x00,0xc6,0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x06,0x0c,0x78,0x00 ; '\x152'
letter153:    db 0x00,0xc6,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '\x153'
letter154:    db 0x00,0xc6,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '\x154'
letter155:    db 0x00,0x18,0x18,0x3c,0x66,0x60,0x60,0x60,0x66,0x3c,0x18,0x18,0x00,0x00,0x00,0x00 ; '\x155'
letter156:    db 0x00,0x38,0x6c,0x64,0x60,0xf0,0x60,0x60,0x60,0x60,0xe6,0xfc,0x00,0x00,0x00,0x00 ; '\x156'
letter157:    db 0x00,0x00,0x66,0x66,0x3c,0x18,0x7e,0x18,0x7e,0x18,0x18,0x18,0x00,0x00,0x00,0x00 ; '\x157'
letter158:    db 0x00,0xf8,0xcc,0xcc,0xf8,0xc4,0xcc,0xde,0xcc,0xcc,0xcc,0xc6,0x00,0x00,0x00,0x00 ; '\x158'
letter159:    db 0x00,0x0e,0x1b,0x18,0x18,0x18,0x7e,0x18,0x18,0x18,0x18,0x18,0xd8,0x70,0x00,0x00 ; '\x159'
letter160:    db 0x00,0x18,0x30,0x60,0x00,0x7c,0x06,0x7e,0xc6,0xc6,0xc6,0x7e,0x00,0x00,0x00,0x00 ; ' '
letter161:    db 0x00,0x0c,0x18,0x30,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00 ; '¡'
letter162:    db 0x00,0x18,0x30,0x60,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '¢'
letter163:    db 0x00,0x18,0x30,0x60,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x00,0x00,0x00,0x00 ; '£'
letter164:    db 0x00,0x00,0x76,0xdc,0x00,0xfc,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00 ; '¤'
letter165:    db 0x76,0xdc,0x00,0xc6,0xe6,0xf6,0xfe,0xde,0xce,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00 ; '¥'
letter166:    db 0x00,0x3c,0x6c,0x6c,0x3e,0x00,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; '¦'
letter167:    db 0x00,0x38,0x6c,0x6c,0x38,0x00,0x7c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; '§'
letter168:    db 0x00,0x00,0x30,0x30,0x00,0x30,0x30,0x60,0xc0,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00 ; '¨'
letter169:    db 0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xc0,0xc0,0xc0,0xc0,0x00,0x00,0x00,0x00,0x00 ; '©'
letter170:    db 0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x06,0x06,0x06,0x06,0x00,0x00,0x00,0x00,0x00 ; 'ª'
letter171:    db 0x00,0x18,0x38,0x18,0x18,0x3c,0x00,0xff,0x00,0x7c,0x06,0x3c,0x60,0x7e,0x00,0x00 ; '«'
letter172:    db 0x00,0x18,0x38,0x18,0x18,0x3c,0x00,0xff,0x00,0x1e,0x36,0x66,0xfe,0x06,0x00,0x00 ; '¬'
letter173:    db 0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00 ; '­'
letter174:    db 0x00,0x00,0x00,0x00,0x00,0x22,0x66,0xee,0x66,0x22,0x00,0x00,0x00,0x00,0x00,0x00 ; '®'
letter175:    db 0x00,0x00,0x00,0x00,0x00,0x88,0xcc,0xee,0xcc,0x88,0x00,0x00,0x00,0x00,0x00,0x00 ; '¯'
letter176:    db 0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44 ; '°'
letter177:    db 0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa ; '±'
letter178:    db 0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77 ; '²'
letter179:    db 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18 ; '³'
letter180:    db 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18 ; '´'
letter181:    db 0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18 ; 'µ'
letter182:    db 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xf6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 ; '¶'
letter183:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 ; '·'
letter184:    db 0x00,0x00,0x00,0x00,0x00,0xf8,0x18,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18 ; '¸'
letter185:    db 0x36,0x36,0x36,0x36,0x36,0xf6,0x06,0xf6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 ; '¹'
letter186:    db 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 ; 'º'
letter187:    db 0x00,0x00,0x00,0x00,0x00,0xfe,0x06,0xf6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 ; '»'
letter188:    db 0x36,0x36,0x36,0x36,0x36,0xf6,0x06,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; '¼'
letter189:    db 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; '½'
letter190:    db 0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; '¾'
letter191:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18 ; '¿'
letter192:    db 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'À'
letter193:    db 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'Á'
letter194:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18 ; 'Â'
letter195:    db 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18 ; 'Ã'
letter196:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'Ä'
letter197:    db 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18 ; 'Å'
letter198:    db 0x18,0x18,0x18,0x18,0x18,0x1f,0x18,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18 ; 'Æ'
letter199:    db 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 ; 'Ç'
letter200:    db 0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'È'
letter201:    db 0x00,0x00,0x00,0x00,0x00,0x3f,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 ; 'É'
letter202:    db 0x36,0x36,0x36,0x36,0x36,0xf7,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'Ê'
letter203:    db 0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xf7,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 ; 'Ë'
letter204:    db 0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 ; 'Ì'
letter205:    db 0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'Í'
letter206:    db 0x36,0x36,0x36,0x36,0x36,0xf7,0x00,0xf7,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 ; 'Î'
letter207:    db 0x18,0x18,0x18,0x18,0x18,0xff,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'Ï'
letter208:    db 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'Ð'
letter209:    db 0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18 ; 'Ñ'
letter210:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 ; 'Ò'
letter211:    db 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'Ó'
letter212:    db 0x18,0x18,0x18,0x18,0x18,0x1f,0x18,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'Ô'
letter213:    db 0x00,0x00,0x00,0x00,0x00,0x1f,0x18,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18 ; 'Õ'
letter214:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 ; 'Ö'
letter215:    db 0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xff,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36 ; '×'
letter216:    db 0x18,0x18,0x18,0x18,0x18,0xff,0x18,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18 ; 'Ø'
letter217:    db 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'Ù'
letter218:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18 ; 'Ú'
letter219:    db 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff ; 'Û'
letter220:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff ; 'Ü'
letter221:    db 0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0 ; 'Ý'
letter222:    db 0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f ; 'Þ'
letter223:    db 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'ß'
letter224:    db 0x00,0x00,0x00,0x00,0x00,0x76,0xdc,0xd8,0xd8,0xd8,0xdc,0x76,0x00,0x00,0x00,0x00 ; 'à'
letter225:    db 0x00,0x00,0x78,0xcc,0xcc,0xcc,0xd8,0xcc,0xc6,0xc6,0xc6,0xcc,0xc0,0xc0,0x00,0x00 ; 'á'
letter226:    db 0x00,0x00,0xfe,0xc6,0xc6,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x00,0x00,0x00,0x00 ; 'â'
letter227:    db 0x00,0x00,0x00,0x00,0xfe,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x00,0x00,0x00,0x00 ; 'ã'
letter228:    db 0x00,0x00,0x00,0xfe,0xc6,0x60,0x30,0x18,0x30,0x60,0xc6,0xfe,0x00,0x00,0x00,0x00 ; 'ä'
letter229:    db 0x00,0x00,0x00,0x00,0x00,0x7e,0xd8,0xd8,0xd8,0xd8,0xd8,0x70,0x00,0x00,0x00,0x00 ; 'å'
letter230:    db 0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x7c,0x60,0x60,0xc0,0x00,0x00,0x00 ; 'æ'
letter231:    db 0x00,0x00,0x00,0x00,0x76,0xdc,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00 ; 'ç'
letter232:    db 0x00,0x00,0x00,0x7e,0x18,0x3c,0x66,0x66,0x66,0x3c,0x18,0x7e,0x00,0x00,0x00,0x00 ; 'è'
letter233:    db 0x00,0x00,0x00,0x38,0x6c,0xc6,0xc6,0xfe,0xc6,0xc6,0x6c,0x38,0x00,0x00,0x00,0x00 ; 'é'
letter234:    db 0x00,0x00,0x38,0x6c,0xc6,0xc6,0xc6,0x6c,0x6c,0x6c,0x6c,0xee,0x00,0x00,0x00,0x00 ; 'ê'
letter235:    db 0x00,0x00,0x1e,0x30,0x18,0x0c,0x3e,0x66,0x66,0x66,0x66,0x3c,0x00,0x00,0x00,0x00 ; 'ë'
letter236:    db 0x00,0x00,0x00,0x00,0x00,0x7e,0xdb,0xdb,0xdb,0x7e,0x00,0x00,0x00,0x00,0x00,0x00 ; 'ì'
letter237:    db 0x00,0x00,0x00,0x03,0x06,0x7e,0xdb,0xdb,0xf3,0x7e,0x60,0xc0,0x00,0x00,0x00,0x00 ; 'í'
letter238:    db 0x00,0x00,0x00,0x00,0x3c,0x60,0x60,0x7c,0x60,0x60,0x3c,0x00,0x00,0x00,0x00,0x00 ; 'î'
letter239:    db 0x00,0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00 ; 'ï'
letter240:    db 0x00,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0x00 ; 'ð'
letter241:    db 0x00,0x00,0x00,0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00,0xff,0x00,0x00,0x00,0x00 ; 'ñ'
letter242:    db 0x00,0x00,0x00,0x30,0x18,0x0c,0x06,0x0c,0x18,0x30,0x00,0x7e,0x00,0x00,0x00,0x00 ; 'ò'
letter243:    db 0x00,0x00,0x00,0x0c,0x18,0x30,0x60,0x30,0x18,0x0c,0x00,0x7e,0x00,0x00,0x00,0x00 ; 'ó'
letter244:    db 0x00,0x00,0x0e,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18 ; 'ô'
letter245:    db 0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xd8,0xd8,0xd8,0x70,0x00,0x00,0x00,0x00 ; 'õ'
letter246:    db 0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x7e,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00 ; 'ö'
letter247:    db 0x00,0x00,0x00,0x00,0x00,0x76,0xdc,0x00,0x76,0xdc,0x00,0x00,0x00,0x00,0x00,0x00 ; '÷'
letter248:    db 0x00,0x38,0x6c,0x6c,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'ø'
letter249:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'ù'
letter250:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'ú'
letter251:    db 0x00,0x0f,0x0c,0x0c,0x0c,0x0c,0x0c,0xec,0x6c,0x6c,0x3c,0x1c,0x00,0x00,0x00,0x00 ; 'û'
letter252:    db 0x00,0xd8,0x6c,0x6c,0x6c,0x6c,0x6c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'ü'
letter253:    db 0x00,0x70,0xd8,0x30,0x60,0xc8,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'ý'
letter254:    db 0x00,0x00,0x00,0x00,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x00,0x00,0x00,0x00,0x00 ; 'þ'
letter255:    db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 ; 'ÿ'
  
  ifdef sea80
  org 0x2000
  endif
  ifdef rc2014
  org 0x4000
  endif

